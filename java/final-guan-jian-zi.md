### final、static、this、super关键字

---

### 一、final关键字:

> **final关键字主要用在三个地方：变量、方法、类。**

* **对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。**

* **使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的Java版本已经不需要使用final方法进行这些优化了）。类中所有的private方法都隐式地指定为final。**

* **当用final修饰一个类时，表明这个类不能被继承。final类中的所有成员方法都会被隐式地指定为final方法。**

### 二、static 关键字:

> 1、java中，人户变量/代码存储时，都是在编译时由系统自动分配内存
>
> 2、在静态变量编译后，所分配的内存会一直存在，直到程序退出内存才会释放这个空间
>
> 3、类加载时，jvm 会把静态变量放到 方法区，被本类&本类的实例所公用

##### 2.1 静态内部类

定义：被static 修饰的类称为静态内部类。该类独立存在，形式上与外部类有内外关系，实际上则没有，本质是为了隐藏自身

```
// 外部类
public class A {  
    // 静态内部类
    public static class B{  
    }  
    // 非静态内部类（即 普通）
    class C{  
    }  
}  

// 静态内部类b & 非静态内部类c 创建时的区别：
A a=new A(); 
A.B b=new A.B(); 
A.C c=a.new C();
```

![](/assets/944365-a2f99e822708f79f.png)

##### 2.2、静态代码块

##### **随着类的加载而执行，只执行一次，并优先于主函数，静态代码块其实就是给类初始化的，而构造代码块是给对象初始化的。**

```
/**
 * 1. 代码块 使用 Static修饰
 * 2. 静态块只会在类加载到内存中时执行1次
 *    a. 若有多个static代码块、变量，JVM将按照它们在类中出现的先后顺序依次执行
 *    b. 静态语句块中只能访问定义在静态语句块之前的变量，定义在它之后的变量可以赋值，但不能访问。如下实例所示
 */

 public class Test { 

     // 使用静态修饰的静态代码块
     static{ 
         i=0;  // 給变量赋值，可通过编译 
         System.out.print(i); // 非法， 提示：“非法向前引用” 
     } 

     static int i=1; 

 }
```

##### 2.3、静态方法

```
/**
 * 1. 可直接通过类名调用，也可通过对象实例调用
 *    （属于类，不属于实例）
 * 2. 任何的实例都可调用（方便共享、公用）
 * 3. 只能访问所属类的静态成员变量 & 方法、不能使用this、super关键字
 *   （this = 调用该函数的对象、但由于静态方法可以直接使用类名调用（即可能还没创建对象），所以不可使用this）
 */

// 静态方法的申明
public static void a(int param) {

}
```

##### 2.4、静态变量

```
/**
 * 1. 静态变量在内存中只有1个拷贝：JVM只为静态分配1次内存
 *   a. 全部对象共用这个static关键字修饰的成员变量，方便对象间共享，节省内存
 *   b. 未被Static修饰的成员变量 = 实例变量：每创建1个实例，JVM就会为实例变量分配1次内存，实例变量在内存中可以有多个拷贝（但互相不影响，更加灵活）
 * 2. 可用类名直接访问：在加载类的过程中完成静态变量的内存分配，（也可通过对象实例访问）
 *  （属于类，不属于实例）
 * 3. 非线程安全：因静态变量被类的所有实例共用
 * 4. 局部变量也能被声明为static
 */

// 静态方法的申明
public class A {  

    private static int count = 0;  //静态变量的申明

}
```

![](/assets/944365-812d65cbdd0c69e0.png)

**1、修饰成员变量和成员方法:** 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。调用格式：类名.静态变量名 类名.静态方法名\(\)

**2、静态代码块:** 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行\(静态代码块—&gt;非静态代码块—&gt;构造方法\)。 该类不管创建多少对象，静态代码块只执行一次.

**3、静态内部类（static修饰类的话只能修饰内部类）： **静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非static成员变量和方法。

**4、静态导包\(用来导入类中的静态资源，1.5之后的新特性\): **格式为：import static 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。

### 三、this 关键字：

> **this关键字用于引用类的当前实例。**

### 四、super 关键字：

> **super关键字用于从子类访问父类的变量和方法**

被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享。而 this 代表对本类对象的引用，指向本类对象；而 super 代表对父类对象的引用，指向父类对象；

所以，**this和super是属于对象范畴的东西，而静态方法是属于类范畴的东西**。

